import common
import construction
import gunsmith
import typing

class _EnergyCartridgeImpl(object):
    """
    Underpowered Cartridge:
    - Damage: If an underpowered cartridge is used the weapon will not be harmed but can only
      deliver the level of damage that cartridge is capable of producing (Field Catalogue p63)
    - Note: The weapon is not damaged when using an overpowered cartridge
    Overpowered Cartridge:
    - Trait: If a cartridge generates more power than the weapon can handle, it is treated as having
      the Unreliable trait at a level equal to the difference between the maximum power generated by
      the cartridge and the damage done by the weapon (Field Catalogue p63).
    - Note: The weapon is not damaged when using an underpowered cartridge
    All Cartridges:
    - Requirement: Only compatible with cartridge energy weapon
    """
    # NOTE: The rules don't explicitly say what the final damage of the weapon is when an overpowered
    # cartridge is used (i.e. does it do the full damage of the cartridge or is it limited by the max
    # damage of the weapon). As it doesn't say what that it does the full damage of the cartridge I've
    # assumed it doesn't
    # NOTE: When it comes to calculating the Unreliable score for overpowered cartridges it's not clear
    # if the damage value used should be the value before or after any damage reductions caused by the
    # type of barrel being used. The worked example (Field Catalogue p63) doesn't say what barrel is
    # being used so it's not clear, however it does refer to the damage value as the maximum damage
    # output. This would suggest it's the pre-barrel modification value (i.e. the power per shot
    # for the receiver rather than the current damage)
    # NOTE: I've added the note that the weapon isn't damaged when using an overpowered cartridge. The
    # rules don't say either way, i've gone with the assumption that they would say if it was.

    def __init__(
            self,
            componentString: str,
            minTechLevel: typing.Union[int, common.ScalarCalculation],
            cartridgeWeight: typing.Union[int, float, common.ScalarCalculation],
            cartridgeCost: typing.Union[int, float, common.ScalarCalculation],
            powerOutput: typing.Union[int, common.ScalarCalculation],
            ) -> None:
        super().__init__()

        if not isinstance(minTechLevel, common.ScalarCalculation):
            minTechLevel = common.ScalarCalculation(
                value=minTechLevel,
                name=f'{componentString} Energy Cartridge Minimum Tech Level')

        if not isinstance(cartridgeWeight, common.ScalarCalculation):
            cartridgeWeight = common.ScalarCalculation(
                value=cartridgeWeight,
                name=f'{componentString} Energy Cartridge Weight')

        if not isinstance(cartridgeCost, common.ScalarCalculation):
            cartridgeCost = common.ScalarCalculation(
                value=cartridgeCost,
                name=f'{componentString} Energy Cartridge Cost')

        if not isinstance(powerOutput, common.ScalarCalculation):
            powerOutput = common.ScalarCalculation(
                value=powerOutput,
                name=f'{componentString} Energy Cartridge Power Output')

        self._componentString = componentString
        self._minTechLevel = minTechLevel
        self._cartridgeWeight = cartridgeWeight
        self._cartridgeCost = cartridgeCost
        self._powerOutput = powerOutput

    def componentString(self) -> str:
        return self._componentString

    def instanceString(self) -> str:
        return self.componentString()

    def isCompatible(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> bool:
        if context.techLevel() < self._minTechLevel.value():
            return False

        # Only compatible with Cartridge Energy Weapons
        return context.hasComponent(
            componentType=gunsmith.EnergyCartridgeReceiver,
            sequence=sequence)

    def options(self) -> typing.List[construction.ComponentOption]:
        return []

    def updateOptions(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> None:
        pass

    def updateStep(
            self,
            sequence: str,
            context: gunsmith.WeaponContext,
            numberOfCartridges: common.ScalarCalculation,
            applyModifiers: bool,
            step:  gunsmith.WeaponStep
            ) -> None:
        totalWeight = common.Calculator.multiply(
            lhs=self._cartridgeWeight,
            rhs=numberOfCartridges,
            name=f'Total Cartridge Weight')
        step.setWeight(weight=construction.ConstantModifier(value=totalWeight))

        totalCost = common.Calculator.multiply(
            lhs=self._cartridgeCost,
            rhs=numberOfCartridges,
            name=f'Total Cartridge Cost')
        step.setCredits(credits=construction.ConstantModifier(value=totalCost))

        powerPerShot = context.attributeValue(
            sequence=sequence,
            attributeId=gunsmith.WeaponAttributeId.PowerPerShot)
        assert(isinstance(powerPerShot, common.ScalarCalculation)) # Construction logic should enforce this

        factors = []
        notes = []

        if self._powerOutput.value() > powerPerShot.value():
            # An overpowered cartridge is being used
            unreliableModifier = common.Calculator.subtract(
                lhs=self._powerOutput,
                rhs=powerPerShot,
                name=f'{self.componentString()} Energy Cartridge Unreliable Modifier Due To Overpowered Cartridge')
            factors.append(construction.ModifyAttributeFactor(
                attributeId=gunsmith.WeaponAttributeId.Unreliable,
                modifier=construction.ConstantModifier(
                    value=unreliableModifier)))
            notes.append(f'Overpowered energy cartridge causes Unreliable +{unreliableModifier.value()}')
        elif self._powerOutput.value() < powerPerShot.value():
            # An underpowered cartridge is being used
            currentDamageRoll = context.attributeValue(
                sequence=sequence,
                attributeId=gunsmith.WeaponAttributeId.Damage)
            assert(isinstance(currentDamageRoll, common.DiceRoll)) # Construction logic should enforce this

            # Calculate the max damage dice that the cartridge allows and the modifier required to
            # the current damage dice to achieve that value. The max damage is the power output of
            # the cartridge limited by the current damage of the weapon, this limiting is done to
            # prevent the final damage being higher than any other damage limits that apply to the
            # weapon (e.g. due to barrel type)
            maxDamageDice = common.Calculator.min(
                lhs=self._powerOutput,
                rhs=currentDamageRoll.dieCount(),
                name=f'{self.componentString()} Energy Cartridge Max Damage Dice Due To Underpowered Cartridge')
            damageDiceModifier = common.Calculator.subtract(
                lhs=maxDamageDice,
                rhs=currentDamageRoll.dieCount(),
                name=f'{self.componentString()} Energy Cartridge Damage Dice Modifier Due To Underpowered Cartridge')

            if damageDiceModifier.value() != 0:
                factors.append(construction.ModifyAttributeFactor(
                    attributeId=gunsmith.WeaponAttributeId.Damage,
                    modifier=construction.DiceRollModifier(
                        countModifier=damageDiceModifier)))
                notes.append(f'Underpowered energy cartridge causes damage reduction of {abs(damageDiceModifier.value())}D')

        for factor in factors:
            if not applyModifiers:
                factor = construction.NonModifyingFactor(factor=factor)
            step.addFactor(factor=factor)

        if applyModifiers:
            for note in notes:
                step.addNote(note=note)

class _WeakEnergyCartridgeImpl(_EnergyCartridgeImpl):
    """
    - Min TL: 9
    - Weight: 0.01kg
    - Cost: Cr5
    - Power Output: 2
    - Damage: If an underpowered cartridge is used the weapon will not be harmed but can only
      deliver the level of damage that cartridge is capable of producing (Field Catalogue p63)
    - Trait: If a cartridge generates more power than the weapon can handle, it is treated as having
      the Unreliable trait at a level equal to the difference between the maximum power generated by
      the cartridge and the damage done by the weapon (Field Catalogue p63).
    - Requirement: Only compatible with Cartridge Power Source
    """

    def __init__(self) -> None:
        super().__init__(
            componentString='Weak',
            minTechLevel=9,
            cartridgeWeight=0.01,
            cartridgeCost=5,
            powerOutput=2)

class _LightEnergyCartridgeImpl(_EnergyCartridgeImpl):
    """
    - Min TL: 10
    - Weight: 0.01kg
    - Cost: Cr8
    - Power Output: 3
    - Damage: If an underpowered cartridge is used the weapon will not be harmed but can only
      deliver the level of damage that cartridge is capable of producing (Field Catalogue p63)
    - Trait: If a cartridge generates more power than the weapon can handle, it is treated as having
      the Unreliable trait at a level equal to the difference between the maximum power generated by
      the cartridge and the damage done by the weapon (Field Catalogue p63).
    - Requirement: Only compatible with Cartridge Power Source
    """

    def __init__(self) -> None:
        super().__init__(
            componentString='Light',
            minTechLevel=10,
            cartridgeWeight=0.01,
            cartridgeCost=8,
            powerOutput=3)

class _StandardEnergyCartridgeImpl(_EnergyCartridgeImpl):
    """
    - Min TL: 11
    - Weight: 0.02kg
    - Cost: Cr10
    - Power Output: 5
    - Damage: If an underpowered cartridge is used the weapon will not be harmed but can only
      deliver the level of damage that cartridge is capable of producing (Field Catalogue p63)
    - Trait: If a cartridge generates more power than the weapon can handle, it is treated as having
      the Unreliable trait at a level equal to the difference between the maximum power generated by
      the cartridge and the damage done by the weapon (Field Catalogue p63).
    - Requirement: Only compatible with Cartridge Power Source
    """

    def __init__(self) -> None:
        super().__init__(
            componentString='Standard',
            minTechLevel=11,
            cartridgeWeight=0.02,
            cartridgeCost=10,
            powerOutput=5)

class _HeavyEnergyCartridgeImpl(_EnergyCartridgeImpl):
    """
    - Min TL: 12
    - Weight: 0.025kg
    - Cost: Cr15
    - Power Output: 8
    - Damage: If an underpowered cartridge is used the weapon will not be harmed but can only
      deliver the level of damage that cartridge is capable of producing (Field Catalogue p63)
    - Trait: If a cartridge generates more power than the weapon can handle, it is treated as having
      the Unreliable trait at a level equal to the difference between the maximum power generated by
      the cartridge and the damage done by the weapon (Field Catalogue p63).
    - Requirement: Only compatible with Cartridge Power Source
    """

    def __init__(self) -> None:
        super().__init__(
            componentString='Heavy',
            minTechLevel=12,
            cartridgeWeight=0.025,
            cartridgeCost=15,
            powerOutput=8)

class EnergyCartridgeLoaded(gunsmith.AmmoLoaded):
    def __init__(
            self,
            impl: _EnergyCartridgeImpl
            ) -> None:
        super().__init__()
        self._impl = impl

    def componentString(self) -> str:
        return self._impl.componentString()

    def instanceString(self) -> str:
        return self._impl.instanceString()

    def typeString(self) -> str:
        return 'Loaded Cartridges'

    def isCompatible(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> bool:
        return self._impl.isCompatible(sequence=sequence, context=context)

    def options(self) -> typing.List[construction.ComponentOption]:
        return self._impl.options()

    def updateOptions(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> None:
        self._impl.updateOptions(sequence=sequence, context=context)

    def createSteps(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> None:
        ammoCapacity = context.attributeValue(
            sequence=sequence,
            attributeId=gunsmith.WeaponAttributeId.AmmoCapacity)
        assert(isinstance(ammoCapacity, common.ScalarCalculation)) # Construction logic should enforce this

        step = gunsmith.WeaponStep(
            name=self.instanceString(),
            type=self.typeString())

        self._impl.updateStep(
            sequence=sequence,
            context=context,
            numberOfCartridges=ammoCapacity,
            applyModifiers=True, # Apply factors to weapon when magazine is loaded
            step=step)

        context.applyStep(
            sequence=sequence,
            step=step)

class WeakEnergyCartridgeLoaded(EnergyCartridgeLoaded):
    """
    Requirement: Weapons with a removable magazine must have a Weak cartridge magazine loaded
    """

    def __init__(self) -> None:
        super().__init__(impl=_WeakEnergyCartridgeImpl())

    def isCompatible(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> bool:
        if not super().isCompatible(sequence=sequence, context=context):
            return False

        # Compatible with all fixed feeds
        if not context.hasComponent(
                componentType=gunsmith.RemovableMagazineFeed,
                sequence=sequence):
            return True

        # The weapon has a removable magazine feed so it must also have a magazine that
        # takes weak energy cartridges loaded
        loadedMagazine = context.findFirstComponent(
            componentType=gunsmith.EnergyCartridgeMagazineLoaded,
            sequence=sequence) # Only interested in magazine from sequence cartridge is part of
        if not loadedMagazine:
            return False
        assert(isinstance(loadedMagazine, gunsmith.EnergyCartridgeMagazineLoaded))
        return loadedMagazine.cartridgeType() == gunsmith.EnergyCartridgeType.Weak

class LightEnergyCartridgeLoaded(EnergyCartridgeLoaded):
    """
    Requirement: Weapons with a removable magazine must have a Light cartridge magazine loaded
    """

    def __init__(self) -> None:
        super().__init__(impl=_LightEnergyCartridgeImpl())

    def isCompatible(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> bool:
        if not super().isCompatible(sequence=sequence, context=context):
            return False

        # Compatible with all fixed feeds
        if not context.hasComponent(
                componentType=gunsmith.RemovableMagazineFeed,
                sequence=sequence):
            return True

        # The weapon has a removable magazine feed so it must also have a magazine that
        # takes light energy cartridges loaded
        loadedMagazine = context.findFirstComponent(
            componentType=gunsmith.EnergyCartridgeMagazineLoaded,
            sequence=sequence) # Only interested in magazine from sequence cartridge is part of
        if not loadedMagazine:
            return False
        assert(isinstance(loadedMagazine, gunsmith.EnergyCartridgeMagazineLoaded))
        return loadedMagazine.cartridgeType() == gunsmith.EnergyCartridgeType.Light

class StandardEnergyCartridgeLoaded(EnergyCartridgeLoaded):
    """
    Requirement: Weapons with a removable magazine must have a Standard cartridge magazine loaded
    """

    def __init__(self) -> None:
        super().__init__(impl=_StandardEnergyCartridgeImpl())

    def isCompatible(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> bool:
        if not super().isCompatible(sequence=sequence, context=context):
            return False

        # Compatible with all fixed feeds
        if not context.hasComponent(
                componentType=gunsmith.RemovableMagazineFeed,
                sequence=sequence):
            return True

        # The weapon has a removable magazine feed so it must also have a magazine that
        # takes standard energy cartridges loaded
        loadedMagazine = context.findFirstComponent(
            componentType=gunsmith.EnergyCartridgeMagazineLoaded,
            sequence=sequence) # Only interested in magazine from sequence cartridge is part of
        if not loadedMagazine:
            return False
        assert(isinstance(loadedMagazine, gunsmith.EnergyCartridgeMagazineLoaded))
        return loadedMagazine.cartridgeType() == gunsmith.EnergyCartridgeType.Standard

class HeavyEnergyCartridgeLoaded(EnergyCartridgeLoaded):
    """
    Requirement: Weapons with a removable magazine must have a Heavy cartridge magazine loaded
    """

    def __init__(self) -> None:
        super().__init__(impl=_HeavyEnergyCartridgeImpl())

    def isCompatible(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> bool:
        if not super().isCompatible(sequence=sequence, context=context):
            return False

        # Compatible with all fixed feeds
        if not context.hasComponent(
                componentType=gunsmith.RemovableMagazineFeed,
                sequence=sequence):
            return True

        # The weapon has a removable magazine feed so it must also have a magazine that
        # takes heavy energy cartridges loaded
        loadedMagazine = context.findFirstComponent(
            componentType=gunsmith.EnergyCartridgeMagazineLoaded,
            sequence=sequence) # Only interested in magazine from sequence cartridge is part of
        if not loadedMagazine:
            return False
        assert(isinstance(loadedMagazine, gunsmith.EnergyCartridgeMagazineLoaded))
        return loadedMagazine.cartridgeType() == gunsmith.EnergyCartridgeType.Heavy

class EnergyCartridgeQuantity(gunsmith.AmmoQuantity):
    def __init__(
            self,
            impl: _EnergyCartridgeImpl
            ) -> None:
        super().__init__()
        self._impl = impl

        self._numberOfCartridgeOption = construction.IntegerOption(
            id='Quantity',
            name='Cartridge',
            value=1,
            minValue=1,
            description='Specify the number of energy cartridges.')

    def componentString(self) -> str:
        return self._impl.componentString()

    def instanceString(self) -> str:
        return f'{self._impl.instanceString()} x{self._numberOfCartridgeOption.value()}'

    def typeString(self) -> str:
        return 'Energy Cartridge Quantity'

    def isCompatible(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> bool:
        return self._impl.isCompatible(sequence=sequence, context=context)

    def options(self) -> typing.List[construction.ComponentOption]:
        options = [self._numberOfCartridgeOption]
        options.extend(self._impl.options())
        return options

    def updateOptions(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> None:
        self._impl.updateOptions(sequence=sequence, context=context)

    def createSteps(
            self,
            sequence: str,
            context: gunsmith.WeaponContext
            ) -> None:
        numberOfCartridges = common.ScalarCalculation(
            value=self._numberOfCartridgeOption.value(),
            name='Specified Number Of Cartridges')

        step = gunsmith.WeaponStep(
            name=self.instanceString(),
            type=self.typeString())

        self._impl.updateStep(
            sequence=sequence,
            context=context,
            numberOfCartridges=numberOfCartridges,
            applyModifiers=False, # Don't apply factors to weapon for quantities, just include them for information
            step=step)

        context.applyStep(
            sequence=sequence,
            step=step)

class WeakEnergyCartridgeQuantity(EnergyCartridgeQuantity):
    def __init__(self) -> None:
        super().__init__(impl=_WeakEnergyCartridgeImpl())

    def createLoadedAmmo(self) -> gunsmith.AmmoLoaded:
        return WeakEnergyCartridgeLoaded()

class LightEnergyCartridgeQuantity(EnergyCartridgeQuantity):
    def __init__(self) -> None:
        super().__init__(impl=_LightEnergyCartridgeImpl())

    def createLoadedAmmo(self) -> gunsmith.AmmoLoaded:
        return LightEnergyCartridgeLoaded()

class StandardEnergyCartridgeQuantity(EnergyCartridgeQuantity):
    def __init__(self) -> None:
        super().__init__(impl=_StandardEnergyCartridgeImpl())

    def createLoadedAmmo(self) -> gunsmith.AmmoLoaded:
        return StandardEnergyCartridgeLoaded()

class HeavyEnergyCartridgeQuantity(EnergyCartridgeQuantity):
    def __init__(self) -> None:
        super().__init__(impl=_HeavyEnergyCartridgeImpl())

    def createLoadedAmmo(self) -> gunsmith.AmmoLoaded:
        return HeavyEnergyCartridgeLoaded()
