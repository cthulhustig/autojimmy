import gui
import math
import random
import time
import typing
from enum import Enum
from PyQt5 import QtWidgets, QtCore, QtGui

# This was generated by chat-gpt as an exercise to see how it handled
# generating something a little complex. I'm incredibly impressed
# with the results. It's something that would have probably taken me
# a couple of weeks to get what I was looking for, and being so
# cosmetic, it probably wouldn't have been worth the effort. However,
# with just 6-7 hours of (pretty painful) prompt manipulation and a
# bit of manual intervention here and there, I've got code that does
# exactly what I need (although some of the 3d to 2d projection code
# it generated is a little hacky).
class DieAnimationWidget(QtWidgets.QWidget):
    animationComplete = QtCore.pyqtSignal()

    class _SpinState(Enum):
        Idle = 0
        Spinning = 1
        FadingIn = 2

    # Define the 8 vertices of a cube in 3D space
    _Vertices = [
        [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],  # Front face
        [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]       # Back face
    ]

    # Define the 6 faces of the cube, with counter-clockwise winding order
    _Faces = [
        (0, 3, 2, 1),  # Front face
        (4, 5, 6, 7),  # Back face
        (0, 1, 5, 4),  # Bottom face
        (2, 3, 7, 6),  # Top face
        (0, 4, 7, 3),  # Left face
        (1, 2, 6, 5)   # Right face
    ]

    _UpdateIntervalMs = 30
    _MinSpins = 4
    _MaxSpins = 10

    def __init__(self, parent: typing.Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._result = None
        self._strike = False
        self._angleX = 0 # TODO: Could these be stored in radians to save converting each time painting occurs
        self._angleY = 0
        self._totalRotationX = 0
        self._totalRotationY = 0
        self._spinDirectionX = 0
        self._spinDirectionY = 0
        self._spinStartTime = None
        self._spinDurationMs = 5000
        self._fadeDurationMs = 1000
        self._fadeInProgress = 0
        self._dieColour = QtGui.QColor('#003366')
        self._textColour = QtGui.QColor('#FFCC00')
        self._strikeColour = QtGui.QColor('#FF0000')
        self._spinState = DieAnimationWidget._SpinState.Idle

        self._lightDirection = (0, 0, -1)  # Light coming from the front
        self._ambientLight = 0

        self._timer = QtCore.QTimer(self)
        self._timer.timeout.connect(self._updateAnimation)

        # Mouse control variables
        self._lastMousePosition = None

        self.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.MinimumExpanding,
            QtWidgets.QSizePolicy.Policy.MinimumExpanding)

    def dieColour(self) -> QtGui.QColor:
        return self._dieColour

    def setDieColour(self, colour: QtGui.QColor) -> None:
        self._dieColour = colour

    def textColour(self) -> QtGui.QColor:
        return self._textColour

    def setTextColour(self, colour: QtGui.QColor) -> None:
        self._textColour = colour

    def strikeColour(self) -> QtGui.QColor:
        return self._strikeColour

    def setStrikeColour(self, colour: QtGui.QColor) -> None:
        self._strikeColour = colour

    def setLightDirection(self) -> typing.Tuple[float, float, float]:
        return self._lightDirection

    def setLightDirection(self, vector: typing.Tuple[float, float, float]) -> None:
        self._lightDirection = vector

    def ambientLight(self) -> float:
        return self._ambientLight

    def setAmbientLight(self, intensity) -> None:
        self._ambientLight = intensity

    def getSpinDuration(self) -> float:
        return self._spinDurationMs

    def setSpinDuration(self, durationMs: float) -> None:
        self._spinDurationMs = durationMs

    def getFadeDuration(self) -> float:
        return self._fadeDurationMs

    def setFadeDuration(self, durationMs: float) -> None:
        self._fadeDurationMs = durationMs

    def setValue(self, result: int, strike: bool = False) -> None:
        if self._spinState != DieAnimationWidget._SpinState.Idle:
            self.cancelSpin()

        self._result = result
        self._strike = strike
        self._fadeInProgress = 1.0
        self.update()  # Trigger repaint

    def startSpin(self, result: int, strike: bool = False) -> None:
        if self._spinState != DieAnimationWidget._SpinState.Idle:
            self.cancelSpin()

        """ Start spinning the cube with a specified number of rotations and directions. """
        self._spinState = DieAnimationWidget._SpinState.Spinning
        self._fadeInProgress = 0
        self._spinStartTime = time.time()  # Record the start time of the spin

        # Generate a random number of full rotations (1 to 4 rotations for example) and spin direction (-1 or 1)
        self._totalRotationX = random.randint(
            DieAnimationWidget._MinSpins,
            DieAnimationWidget._MaxSpins) * 360  # Full rotations for the X-axis
        self._totalRotationY = random.randint(
            DieAnimationWidget._MinSpins,
            DieAnimationWidget._MaxSpins) * 360  # Full rotations for the Y-axis
        self._spinDirectionX = random.choice([-1, 1])  # Direction of spin (-1 for counterclockwise, 1 for clockwise)
        self._spinDirectionY = random.choice([-1, 1])  # Direction of spin

        self._result = result  # Store the number to display after the spin
        self._strike = strike

        self._timer.start(30)  # Update every 30 milliseconds

    def skipSpin(self) -> None:
        if self._spinState != DieAnimationWidget._SpinState.Spinning:
            return # Nothing to do

        self._spinState = DieAnimationWidget._SpinState.FadingIn
        self._angleX = 0
        self._angleY = 0
        self.update()  # Trigger repaint

    def cancelSpin(self) -> None:
        self._angleX = 0
        self._angleY = 0
        self._spinState = DieAnimationWidget._SpinState.Idle
        self._result = None
        self._strike = False
        self._timer.stop()

    def minimumSizeHint(self) -> QtCore.QSize:
        return QtCore.QSize(30, 30)

    def sizeHint(self) -> QtCore.QSize:
        return QtCore.QSize(100, 100)

    def paintEvent(self, event) -> None:
        # TODO: Should I be calling painter.end
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)

        # Cube rendering settings
        width = self.width()
        height = self.height()

        fov = self._calculateFov(width, height)

        # Rotate and project each vertex
        projectedVertices: typing.List[typing.Tuple[
            typing.Tuple[float, float, float],
            typing.Tuple[int, int]]] = []
        for vertex in DieAnimationWidget._Vertices:
            rotatedVertex = self._rotatePoint(*vertex)
            projected2d = self._project3dTo2d(*rotatedVertex, width, height, fov)
            projectedVertices.append((rotatedVertex, projected2d))

        # Draw each face if visible
        frontFaceRect = None
        for face in DieAnimationWidget._Faces:
            p1_3d, p1_2d = projectedVertices[face[0]]
            p2_3d, p2_2d = projectedVertices[face[1]]
            p3_3d, p3_2d = projectedVertices[face[2]]
            p4_3d, p4_2d = projectedVertices[face[3]]

            # Calculate the normal of the face using the transformed 3D vertices
            normal = self._faceNormal(p1_3d, p2_3d, p3_3d)

            # Check if the face is visible
            if self._isFaceVisible(normal):
                # Calculate the light intensity for flat shading
                intensity = self._calculateLightIntensity(normal)

                # Apply the intensity to the base color
                shadedColor = QtGui.QColor(
                    min(255, int(self._dieColour.red() * intensity)),
                    min(255, int(self._dieColour.green() * intensity)),
                    min(255, int(self._dieColour.blue() * intensity))
                )

                # Draw the face as a polygon
                painter.setBrush(QtGui.QBrush(shadedColor))
                polygon = QtGui.QPolygon([
                    QtCore.QPoint(*p1_2d),
                    QtCore.QPoint(*p2_2d),
                    QtCore.QPoint(*p3_2d),
                    QtCore.QPoint(*p4_2d)])
                painter.drawPolygon(polygon)

                # Capture the front face bounding box for number display later
                if face == DieAnimationWidget._Faces[0]:  # Front face
                    xCoords = [p1_2d[0], p2_2d[0], p3_2d[0], p4_2d[0]]
                    yCoords = [p1_2d[1], p2_2d[1], p3_2d[1], p4_2d[1]]
                    minX, maxX = min(xCoords), max(xCoords)
                    minY, maxY = min(yCoords), max(yCoords)
                    frontFaceRect = QtCore.QRect(minX, minY, maxX - minX, maxY - minY)

        # After spinning, draw the number on the front face
        if self._spinState != DieAnimationWidget._SpinState.Spinning and self._result is not None:
            assert(frontFaceRect)
            displayText = str(self._result)

            # Calculate font size based on the size of the front face
            margin = 0.1  # 10% margin on each side
            availableWidth = int(frontFaceRect.width() * (1 - 2 * margin))
            availableHeight = int(frontFaceRect.height() * (1 - 2 * margin))
            font = gui.sizeFontToFit(
                orig=self.font(),
                text=displayText,
                rect=QtCore.QRect(0, 0, availableWidth, availableHeight))
            if font:
                # Set font and color
                painter.setPen(QtGui.QPen(self._textColour, 1))
                painter.setFont(font)

                # Calculate the position to center the text in the front face
                textRect = painter.fontMetrics().boundingRect(displayText)
                ascent = painter.fontMetrics().ascent()
                descent = painter.fontMetrics().descent()

                # Calculate the text opacity based on fade progress
                painter.setOpacity(self._fadeInProgress)

                # Draw the number in the center of the front face
                painter.drawText(
                    frontFaceRect.center().x() - textRect.width() // 2,
                    frontFaceRect.center().y() + (ascent - descent) // 2,
                    displayText)

                if self._strike:
                    painter.setOpacity(self._fadeInProgress * 0.8)
                    strikeExpand = int(frontFaceRect.width() * 0.1)
                    stringWidth = int(frontFaceRect.width() * 0.15)
                    strikeRect = QtCore.QRect(frontFaceRect)
                    strikeRect.adjust(
                        -strikeExpand,
                        -strikeExpand,
                        strikeExpand,
                        strikeExpand)
                    painter.setPen(QtGui.QPen(
                        self._strikeColour,
                        stringWidth,
                        QtCore.Qt.PenStyle.SolidLine,
                        QtCore.Qt.PenCapStyle.RoundCap))
                    painter.drawLine(
                        strikeRect.topRight(),
                        strikeRect.bottomLeft())

                painter.setOpacity(1.0)  # Reset the painter's opacity

    """
    def mousePressEvent(self, event: QtGui.QMouseEvent) -> None:
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self._lastMousePosition = event.pos()

    def mouseMoveEvent(self, event: QtGui.QMouseEvent) -> None:
        if self._lastMousePosition is not None:
            dx = event.x() - self._lastMousePosition.x()
            dy = event.y() - self._lastMousePosition.y()

            self._angleY += dx * 0.5  # Adjust sensitivity as needed
            self._angleX -= dy * 0.5  # Adjust sensitivity as needed

        self._lastMousePosition = event.pos()

    def mouseReleaseEvent(self, event: QtGui.QMouseEvent) -> None:
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self._lastMousePosition = None  # Reset on mouse release
    """

    def _easingFunction(self, progress: float) -> float:
        """ A cubic easing function to smoothly slow down the rotation. """
        return 1 - (1 - progress) ** 3  # Smooth out the transition

    def _updateAnimation(self) -> None:
        wasAnimating = self._spinState != DieAnimationWidget._SpinState.Idle

        try:
            if self._spinState == DieAnimationWidget._SpinState.Spinning:
                elapsedTimeMs = (time.time() - self._spinStartTime) * 1000

                # Progress of the animation (0.0 to 1.0)
                animationProgress = min(1.0, elapsedTimeMs / self._spinDurationMs)

                # Easing the progress
                easedProgress = self._easingFunction(animationProgress)

                # Calculate the current angle based on the total rotations, spin direction, and progress
                self._angleX = self._spinDirectionX * easedProgress * self._totalRotationX
                self._angleY = self._spinDirectionY * easedProgress * self._totalRotationY

                # Stop spinning when the progress is done
                if animationProgress >= 1.0:
                    self._angleX = self._snapToNearestFace(self._angleX)
                    self._angleY = self._snapToNearestFace(self._angleY)
                    self._spinState = DieAnimationWidget._SpinState.FadingIn

            if self._spinState == DieAnimationWidget._SpinState.FadingIn:
                increment = 1 / (self._fadeDurationMs / DieAnimationWidget._UpdateIntervalMs)
                self._fadeInProgress += increment
                if self._fadeInProgress >= 1.0:
                    self._fadeInProgress = 1.0
                    self._spinState = DieAnimationWidget._SpinState.Idle
        except Exception as ex:
            # TODO: Should log this
            self._angleX = self._angleY = 0
            self._spinState = DieAnimationWidget._SpinState.Idle

        self.update()  # Trigger repaint

        isAnimated = self._spinState != DieAnimationWidget._SpinState.Idle
        if wasAnimating and not isAnimated:
            self._timer.stop()
            self.animationComplete.emit()

    def _snapToNearestFace(self, angle: float) -> float:
        """ Snap the angle to the nearest face (multiples of 90 degrees). """
        return round(angle / 90) * 90

    def _rotatePoint(
            self,
            x: float,
            y: float,
            z: float,
            ) -> typing.Tuple[float, float, float]:
        """ Apply 3D rotation around X, Y, and Z axes. """
        # Rotate around X-axis
        cosX, sinX = math.cos(math.radians(self._angleX)), math.sin(math.radians(self._angleX))
        y, z = y * cosX - z * sinX, y * sinX + z * cosX

        # Rotate around Y-axis
        cosY, sinY = math.cos(math.radians(self._angleY)), math.sin(math.radians(self._angleY))
        x, z = x * cosY + z * sinY, -x * sinY + z * cosY

        return x, y, z

    def _calculateFov(
            self,
            width: int,
            height: int
            ) -> float:
        """ Calculate the required FOV to make spinning cube fill the available space without extending outside it """
        distance = max(0.1, 4 + -1)
        minDimension = width if width < height else height
        minDimension *= 0.7
        return (minDimension / 2) * distance / 1

    def _project3dTo2d(
            self,
            x: float,
            y: float,
            z: float,
            width: int,
            height: int,
            fov: float
            ) -> typing.Tuple[int, int]:
        """ Simple perspective projection of 3D point onto 2D screen. """
        distance = max(0.1, 4 + z)  # Avoid division by zero

        factor = fov / distance
        projX = x * factor + width / 2
        projY = -y * factor + height / 2  # Invert Y-axis for correct orientation

        return (int(projX), int(projY))

    def _faceNormal(
            self,
            v1: typing.Tuple[float, float, float],
            v2: typing.Tuple[float, float, float],
            v3: typing.Tuple[float, float, float]
            ) -> typing.Tuple[float, float, float]:
        """ Calculate the normal of a face using the cross product of two vectors. """
        ax, ay, az = v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]
        bx, by, bz = v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]

        nx = ay * bz - az * by
        ny = az * bx - ax * bz
        nz = ax * by - ay * bx

        # Calculate the magnitude of the normal vector
        magnitude = math.sqrt(nx**2 + ny**2 + nz**2)

        # Normalize the normal vector if the magnitude is not zero
        if magnitude > 0:
            nx /= magnitude
            ny /= magnitude
            nz /= magnitude

        return nx, ny, nz

    def _calculateLightIntensity(self, normal: typing.Tuple[float, float, float]) -> float:
        """ Calculate light intensity based on the normal direction. """
        intensity = max(0, self._dotProduct(normal, self._lightDirection))  # Clamp to 0 for no negative light
        intensity = min(1.0, intensity + self._ambientLight)

        # Return intensity as a value between 0 and 1
        return intensity

    def _isFaceVisible(self, normal: typing.Tuple[float, float, float]) -> bool:
        """ Determine if a face is visible based on its normal direction. """
        # NOTE: When chat-gpt generated the code it sets this to 0. However,
        # that results in draw artifacts because some edges that shouldn't be
        # visible are draw. I think it has something to do with the fact the
        # normal check isn't taking perspective projection into acount but
        # I can't figure out what it should do (chat-gpt has been no help).
        # The value of -0.25 was derived from looking at what the values
        # were in the debugger at the point edges should have disappeared but
        # haven't.
        return normal[2] < -0.25  # Simple visibility check: face normal pointing towards the camera

    def _dotProduct(self, v1: typing.Tuple[float, float, float], v2: typing.Tuple[float, float, float]) -> float:
        """ Calculate the dot product of two vectors. """
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]
