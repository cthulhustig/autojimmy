import common
import enum
import gui
import logging
import math
import random
import time
import typing
from PyQt5 import QtWidgets, QtCore, QtGui

_D6Vertices = [
    # Front face
    (-1, -1, -1),
    (+1, -1, -1),
    (+1, +1, -1),
    (-1, +1, -1),
    # Back face
    (-1, -1, +1),
    (+1, -1, +1),
    (+1, +1, +1),
    (-1, +1, +1)
]

_D6Faces = [
    (0, 3, 2, 1),  # Front face
    (4, 5, 6, 7),  # Back face
    (0, 1, 5, 4),  # Bottom face
    (2, 3, 7, 6),  # Top face
    (0, 4, 7, 3),  # Left face
    (1, 2, 6, 5)   # Right face
]

_D10Vertices = [
    (-0.000031, -1.224734, -0.538529),
    (-1.522723, +0.516764, -0.383498),
    (-0.941143, +0.485053, -1.209551),
    (+0.941081, +0.485053, -1.209551),
    (-0.000031, +0.888711, -1.368025),
    (-0.000031, +1.624737, +0.538460),
    (+0.941081, -0.085022, +1.209584),
    (-0.000031, -0.488679, +1.368060),
    (+1.522769, -0.116759, +0.383430),
    (+1.522769, +0.516764, -0.383498),
    (-1.522723, -0.116759, +0.383430),
    (-0.941143, -0.085022, +1.209584),
]

_D10Faces = [
    (0, 2, 4, 3),
    (0, 3, 9, 8),
    (0, 10, 1, 2),
    (0, 8, 6, 7),
    (0, 7, 11, 10),

    (5, 9, 3, 4),
    (5, 4, 2, 1),
    (5, 1, 10, 11),
    (5, 6, 8, 9),
    (5, 11, 7, 6)
]

_D20Vertices = [
    (-1.213522, -0.700616, -0.267640),
    (+0.000001, -0.865941, -1.133683),
    (+0.000001, -1.401276, +0.267473),
    (-0.750007, +0.433143, -1.133683),
    (+1.213526, +0.700590, +0.267716),
    (+0.000001, +0.865930, +1.133700),
    (+0.750000, -0.433108, +1.133589),
    (+0.000001, +1.401267, -0.267455),
    (-0.750007, -0.433108, +1.133589),
    (-1.213522, +0.700590, +0.267716),
    (+0.750000, +0.433143, -1.133683),
    (+1.213526, -0.700616, -0.267640),
]

_D20Faces = [
    (10, 1, 3),
    (1, 10, 11),
    (4, 11, 10),
    (6, 11, 4),
    (4, 5, 6),
    (6, 5, 8),
    (8, 5, 9),
    (8, 9, 0),
    (9, 3, 0),
    (3, 1, 0),
    (7, 3, 9),
    (7, 5, 4),
    (7, 9, 5),
    (7, 4, 10),
    (7, 10, 3),
    (0, 1, 2),
    (11, 6, 2),
    (2, 6, 8),
    (2, 8, 0),
    (1, 11, 2),
]

_DieTypeModels = {
    common.DieType.D6: (_D6Vertices, _D6Faces),
    common.DieType.D3: (_D6Vertices, _D6Faces),
    common.DieType.DD: (_D6Vertices, _D6Faces),
    common.DieType.D10: (_D10Vertices, _D10Faces),
    common.DieType.D20: (_D20Vertices, _D20Faces),
}

_360DegreesInRadians = math.radians(360)

# This was generated by chat-gpt as an exercise to see how it handled
# generating something a little complex. I'm incredibly impressed
# with the results. It's something that would have probably taken me
# a couple of weeks to get what I was looking for, and being so
# cosmetic, it probably wouldn't have been worth the effort. However,
# with just 6-7 hours of (pretty painful) prompt manipulation and a
# bit of manual intervention here and there, I've got code that does
# exactly what I need (although some of the 3d to 2d projection code
# it generated is a little hacky).
class DieAnimationWidget(QtWidgets.QWidget):
    animationComplete = QtCore.pyqtSignal()

    class _SpinState(enum.Enum):
        Idle = 0
        Spinning = 1
        FadingIn = 2

    _UpdateIntervalMs = 30
    _MinSpins = 4
    _MaxSpins = 10

    def __init__(self, parent: typing.Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._dieType = None
        self._result = None
        self._strike = False
        self._angleX = 0
        self._angleY = 0
        self._totalRotationX = 0
        self._totalRotationY = 0
        self._spinStartTime = None
        self._spinDurationMs = 5000
        self._fadeDurationMs = 500
        self._fadeInProgress = 0
        self._dieFillColour = QtGui.QColor('#003366')
        self._dieEdgeColour = self._dieFillColour.lighter(280)
        self._textColour = QtGui.QColor('#FFCC00')
        self._strikeColour = QtGui.QColor('#FF0000')
        self._spinState = DieAnimationWidget._SpinState.Idle

        self._lightDirection = (0, 0, -1)  # Light coming from the front
        self._ambientLight = 0

        self._timer = QtCore.QTimer(self)
        self._timer.timeout.connect(self._updateAnimation)

        # Mouse control variables
        self._lastMousePosition = None

        self.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.MinimumExpanding,
            QtWidgets.QSizePolicy.Policy.MinimumExpanding)

    def dieType(self) -> typing.Optional[common.DieType]:
        return self._dieType

    def setDieType(self, dieType: typing.Optional[common.DieType]):
        self._dieType = dieType
        self.update() # Trigger redraw

    def dieFillColour(self) -> QtGui.QColor:
        return self._dieFillColour

    def setDieFillColour(self, colour: QtGui.QColor) -> None:
        self._dieFillColour = colour

    def dieEdgeColour(self) -> QtGui.QColor:
        return self._dieEdgeColour

    def setDieEdgeColour(self, colour: QtGui.QColor) -> None:
        self._dieEdgeColour = colour

    def textColour(self) -> QtGui.QColor:
        return self._textColour

    def setTextColour(self, colour: QtGui.QColor) -> None:
        self._textColour = colour

    def strikeColour(self) -> QtGui.QColor:
        return self._strikeColour

    def setStrikeColour(self, colour: QtGui.QColor) -> None:
        self._strikeColour = colour

    def setLightDirection(self) -> typing.Tuple[float, float, float]:
        return self._lightDirection

    def setLightDirection(self, vector: typing.Tuple[float, float, float]) -> None:
        self._lightDirection = vector

    def ambientLight(self) -> float:
        return self._ambientLight

    def setAmbientLight(self, intensity) -> None:
        self._ambientLight = intensity

    def getSpinDuration(self) -> float:
        return self._spinDurationMs

    def setSpinDuration(self, durationMs: float) -> None:
        self._spinDurationMs = durationMs

    def getFadeDuration(self) -> float:
        return self._fadeDurationMs

    def setFadeDuration(self, durationMs: float) -> None:
        self._fadeDurationMs = durationMs

    def setValue(self, result: int, strike: bool = False) -> None:
        if self._spinState != DieAnimationWidget._SpinState.Idle:
            self.cancelSpin()

        self._result = result
        self._strike = strike
        self._fadeInProgress = 1.0
        self.update()  # Trigger repaint

    def startSpin(self, result: int, strike: bool = False) -> None:
        if self._spinState != DieAnimationWidget._SpinState.Idle:
            self.cancelSpin()

        """ Start spinning the cube with a specified number of rotations and directions. """
        self._spinState = DieAnimationWidget._SpinState.Spinning
        self._fadeInProgress = 0
        self._spinStartTime = time.time()  # Record the start time of the spin

        self._totalRotationX = DieAnimationWidget._randomSpinAngle()
        self._totalRotationY = DieAnimationWidget._randomSpinAngle()

        self._result = result  # Store the number to display after the spin
        self._strike = strike

        self._timer.start(30)  # Update every 30 milliseconds

    def skipSpin(self) -> None:
        if self._spinState == DieAnimationWidget._SpinState.Idle:
            return # Nothing to do

        self._spinState = DieAnimationWidget._SpinState.Idle
        self._angleX = 0
        self._angleY = 0
        self._fadeInProgress = 1.0

        self._timer.stop()
        self.animationComplete.emit()

        self.update()  # Trigger repaint

    def cancelSpin(self) -> None:
        self._angleX = 0
        self._angleY = 0
        self._spinState = DieAnimationWidget._SpinState.Idle
        self._result = None
        self._strike = False
        self._fadeInProgress = 0.0
        self._timer.stop()

    def minimumSizeHint(self) -> QtCore.QSize:
        return QtCore.QSize(30, 30)

    def sizeHint(self) -> QtCore.QSize:
        return QtCore.QSize(100, 100)

    def paintEvent(self, event) -> None:
        if not self._dieType:
            return

        painter = QtGui.QPainter(self)
        try:
            painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)

            # Cube rendering settings
            width = self.width()
            height = self.height()

            fov = DieAnimationWidget._calculateFov(width, height)

            vertices, faces = _DieTypeModels[self._dieType]

            # Rotate and project each vertex
            projectedVertices: typing.List[typing.Tuple[
                typing.Tuple[float, float, float],
                typing.Tuple[int, int]]] = []
            for vertex in vertices:
                rotatedVertex = self._rotatePoint(*vertex)
                projected2d = DieAnimationWidget._project3dTo2d(*rotatedVertex, width, height, fov)
                projectedVertices.append((rotatedVertex, projected2d))

            # Draw each face if visible
            renderRect = None
            for face in faces:
                p1_3d, _ = projectedVertices[face[0]]
                p2_3d, _ = projectedVertices[face[1]]
                p3_3d, _ = projectedVertices[face[2]]

                # Calculate the normal of the face using the transformed 3D vertices.
                # For the D6 the face is split into a right angled triangle covering
                # half the face. This works on the assumption that the entire face is
                # on the same plane
                normal = DieAnimationWidget._faceNormal(p1_3d, p2_3d, p3_3d)

                # Check if the face is visible
                if DieAnimationWidget._isFaceVisible(normal):
                    # Calculate the light intensity for flat shading
                    intensity = self._calculateLightIntensity(normal)

                    # Apply the intensity to the base color
                    fillColor = self._shadeColour(
                        colour=self._dieFillColour,
                        intensity=intensity)
                    edgeColour = self._shadeColour(
                        colour=self._dieEdgeColour,
                        intensity=intensity)

                    # Draw the face as a polygon
                    polygon = QtGui.QPolygon()
                    for index in face:
                        _, p_2d = projectedVertices[index]
                        polygon.append(QtCore.QPoint(*p_2d))
                    painter.setBrush(QtGui.QBrush(fillColor))
                    painter.setPen(edgeColour)
                    painter.drawPolygon(polygon)

                    polyRect = polygon.boundingRect()
                    if renderRect == None:
                        renderRect = polyRect
                    else:
                        renderRect = renderRect.united(polyRect)

            # After spinning, draw the number on the front face
            if self._spinState != DieAnimationWidget._SpinState.Spinning and self._result is not None:
                assert(renderRect is not None)
                displayText = str(self._result)
                displayRect = QtCore.QRect(renderRect)

                # Calculate font size based on the size of the front face
                margin = 0.1  # 10% margin on each side
                availableWidth = int(displayRect.width() * (1 - 2 * margin))
                availableHeight = int(displayRect.height() * (1 - 2 * margin))
                font = gui.sizeFontToFit(
                    orig=self.font(),
                    text=displayText,
                    rect=QtCore.QRect(0, 0, availableWidth, availableHeight))
                if font:
                    # Set font and color
                    painter.setPen(QtGui.QPen(self._textColour, 1))
                    painter.setFont(font)

                    # Calculate the position to center the text in the front face
                    textRect = painter.fontMetrics().boundingRect(displayText)
                    ascent = painter.fontMetrics().ascent()
                    descent = painter.fontMetrics().descent()

                    # Calculate the text opacity based on fade progress
                    painter.setOpacity(self._fadeInProgress)

                    # Draw the number in the center of the front face
                    painter.drawText(
                        displayRect.center().x() - textRect.width() // 2,
                        displayRect.center().y() + (ascent - descent) // 2,
                        displayText)

                    if self._strike:
                        painter.setOpacity(self._fadeInProgress * 0.8)
                        maxRenderDim = max(renderRect.width(), renderRect.height())
                        strikeRect = QtCore.QRect(renderRect)
                        strikeExpand = int(maxRenderDim * 0.1)
                        strikeRect.adjust(
                            -strikeExpand,
                            -strikeExpand,
                            strikeExpand,
                            strikeExpand)
                        strikeRect = strikeRect.marginsRemoved(QtCore.QMargins(
                            0,
                            int(strikeRect.height() * (1.0 - self._fadeInProgress)),
                            int(strikeRect.width() * (1.0 - self._fadeInProgress)),
                            0))
                        penWidth = int(maxRenderDim * 0.15)
                        painter.setPen(QtGui.QPen(
                            self._strikeColour,
                            penWidth,
                            QtCore.Qt.PenStyle.SolidLine,
                            QtCore.Qt.PenCapStyle.RoundCap))
                        painter.drawLine(
                            strikeRect.bottomLeft(),
                            strikeRect.topRight())

                    painter.setOpacity(1.0)  # Reset the painter's opacity
        finally:
            painter.end()

    """
    def mousePressEvent(self, event: QtGui.QMouseEvent) -> None:
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self._lastMousePosition = event.pos()

    def mouseMoveEvent(self, event: QtGui.QMouseEvent) -> None:
        if self._lastMousePosition is not None:
            dx = event.x() - self._lastMousePosition.x()
            dy = event.y() - self._lastMousePosition.y()

            self._angleY += dx * 0.5  # Adjust sensitivity as needed
            self._angleX -= dy * 0.5  # Adjust sensitivity as needed

        self._lastMousePosition = event.pos()

    def mouseReleaseEvent(self, event: QtGui.QMouseEvent) -> None:
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self._lastMousePosition = None  # Reset on mouse release
    """

    def _updateAnimation(self) -> None:
        wasAnimating = self._spinState != DieAnimationWidget._SpinState.Idle

        try:
            if self._spinState == DieAnimationWidget._SpinState.Spinning:
                elapsedTimeMs = (time.time() - self._spinStartTime) * 1000

                # Progress of the animation (0.0 to 1.0)
                animationProgress = min(1.0, elapsedTimeMs / self._spinDurationMs)

                # Easing the progress
                easedProgress = DieAnimationWidget._easingFunction(animationProgress)

                # Calculate the current angle based on the total rotations and progress
                self._angleX = easedProgress * self._totalRotationX
                self._angleY = easedProgress * self._totalRotationY

                # Stop spinning when the progress is done
                if animationProgress >= 1.0:
                    self._angleX = 0
                    self._angleY = 0
                    self._spinState = DieAnimationWidget._SpinState.FadingIn

            if self._spinState == DieAnimationWidget._SpinState.FadingIn:
                increment = 1 / (self._fadeDurationMs / DieAnimationWidget._UpdateIntervalMs)
                self._fadeInProgress += increment
                if self._fadeInProgress >= 1.0:
                    self._fadeInProgress = 1.0
                    self._spinState = DieAnimationWidget._SpinState.Idle
        except Exception as ex:
            logging.error('Failed to update die animation', exc_info=ex)
            self._angleX = self._angleY = 0
            self._spinState = DieAnimationWidget._SpinState.Idle

        self.update()  # Trigger repaint

        isAnimated = self._spinState != DieAnimationWidget._SpinState.Idle
        if wasAnimating and not isAnimated:
            self._timer.stop()
            self.animationComplete.emit()

    def _rotatePoint(
            self,
            x: float,
            y: float,
            z: float,
            ) -> typing.Tuple[float, float, float]:
        """ Apply 3D rotation around X, Y, and Z axes. """
        # Rotate around X-axis
        cosX, sinX = math.cos(self._angleX), math.sin(self._angleX)
        y, z = y * cosX - z * sinX, y * sinX + z * cosX

        # Rotate around Y-axis
        cosY, sinY = math.cos(self._angleY), math.sin(self._angleY)
        x, z = x * cosY + z * sinY, -x * sinY + z * cosY

        return x, y, z

    def _calculateLightIntensity(self, normal: typing.Tuple[float, float, float]) -> float:
        """ Calculate light intensity based on the normal direction. """
        intensity = max(0, DieAnimationWidget._dotProduct(normal, self._lightDirection))  # Clamp to 0 for no negative light
        intensity = min(1.0, intensity + self._ambientLight)

        # Return intensity as a value between 0 and 1
        return intensity

    @staticmethod
    def _randomSpinAngle() -> float:
        angle = random.randint(
            DieAnimationWidget._MinSpins,
            DieAnimationWidget._MaxSpins) * _360DegreesInRadians  # Random number of full rotations
        angle *= random.choice([-1, 1]) # Direction of spin (-1 for counterclockwise, 1 for clockwise)
        return angle

    @staticmethod
    def _easingFunction(progress: float) -> float:
        """ A cubic easing function to smoothly slow down the rotation. """
        return 1 - (1 - progress) ** 3  # Smooth out the transition

    @staticmethod
    def _calculateFov(
            width: int,
            height: int
            ) -> float:
        """ Calculate the required FOV to make spinning cube fill the available space without extending outside it """
        distance = max(0.1, 4 + -1)
        minDimension = width if width < height else height
        minDimension *= 0.7
        return (minDimension / 2) * distance / 1

    @staticmethod
    def _project3dTo2d(
            x: float,
            y: float,
            z: float,
            width: int,
            height: int,
            fov: float
            ) -> typing.Tuple[int, int]:
        # Convert FoV from degrees to radians
        fov = math.radians(55)

        # Compute the focal length from the FoV
        focalLength = width / (2 * math.tan(fov / 2))

        # Avoid division by zero for points at z = 0
        z += 4
        if z == 0:
            z = 1e-5

        # Perspective projection formula using focal length derived from FoV
        x_2d = ((focalLength * x) / z) + (width / 2)
        y_2d = ((focalLength * -y) / z) + (height / 2)

        return int(x_2d), int(y_2d)

    @staticmethod
    def _faceNormal(
            v1: typing.Tuple[float, float, float],
            v2: typing.Tuple[float, float, float],
            v3: typing.Tuple[float, float, float]
            ) -> typing.Tuple[float, float, float]:
        """ Calculate the normal of a face using the cross product of two vectors. """
        ax, ay, az = v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]
        bx, by, bz = v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]

        nx = ay * bz - az * by
        ny = az * bx - ax * bz
        nz = ax * by - ay * bx

        # Calculate the magnitude of the normal vector
        magnitude = math.sqrt(nx**2 + ny**2 + nz**2)

        # Normalize the normal vector if the magnitude is not zero
        if magnitude > 0:
            nx /= magnitude
            ny /= magnitude
            nz /= magnitude

        return nx, ny, nz

    @staticmethod
    def _isFaceVisible(normal: typing.Tuple[float, float, float]) -> bool:
        """ Determine if a face is visible based on its normal direction. """
        # NOTE: When chat-gpt generated the code it sets this to 0. However,
        # that results in draw artifacts because some edges that shouldn't be
        # visible are draw. I think it has something to do with the fact the
        # normal check isn't taking perspective projection into acount but
        # I can't figure out what it should do (chat-gpt has been no help) and
        # it doesn't seem worth the time trying to figure it out when this
        # hack seems to work.
        # The value of -0.26 was derived from looking at what the values
        # were in the debugger at the point edges should have disappeared but
        # haven't. It was originally -0.25 which was fine for a D6 but when
        # I added D10 & D20 support I found I needed to tweak it to -0.24 so
        # that heavily sloped faces weren't being incorrectly culled.
        # NOTE: When using orthogonal projection this value should be set to 0.0
        return normal[2] < -0.24  # Simple visibility check: face normal pointing towards the camera

    @staticmethod
    def _dotProduct(
            v1: typing.Tuple[float, float, float],
            v2: typing.Tuple[float, float, float]
            ) -> float:
        """ Calculate the dot product of two vectors. """
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]

    @staticmethod
    def _shadeColour(
            colour: QtGui.QColor,
            intensity: float
            ) -> QtGui.QColor:
        return QtGui.QColor(
            min(255, int(colour.red() * intensity)),
            min(255, int(colour.green() * intensity)),
            min(255, int(colour.blue() * intensity)))
