import common
import gui
import logging
import math
import random
import time
import typing
from enum import Enum
from PyQt5 import QtWidgets, QtCore, QtGui

# Define the 8 vertices of a cube in 3D space
_D6Vertices = [
    [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],  # Front face
    [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]       # Back face
]

# Define the 6 faces of the cube, with counter-clockwise winding order
_D6Faces = [
    (0, 3, 2, 1),  # Front face
    (4, 5, 6, 7),  # Back face
    (0, 1, 5, 4),  # Bottom face
    (2, 3, 7, 6),  # Top face
    (0, 4, 7, 3),  # Left face
    (1, 2, 6, 5)   # Right face
]

_D10Vertices = [
    [-0.000026, -1.187278, -0.448774],
    [-1.268936, +0.263970, -0.319582],
    [-0.784286, +0.237544, -1.007959],
    [+0.784234, +0.237544, -1.007959],
    [-0.000026, +0.573926, -1.140021],
    [-0.000026, +1.187281, +0.448717],
    [+0.784234, -0.237518, +1.007987],
    [-0.000026, -0.573899, +1.140050],
    [+1.268974, -0.263966, +0.319525],
    [+1.268974, +0.263970, -0.319582],
    [-1.268936, -0.263966, +0.319525],
    [-0.784286, -0.237518, +1.007987],
]

_D10Faces = [
    (0, 2, 4, 3),
    (0, 3, 9, 8),
    (0, 10, 1, 2),
    (0, 8, 6, 7),
    (0, 7, 11, 10),

    (5, 9, 3, 4),
    (5, 4, 2, 1),
    (5, 1, 10, 11),
    (5, 6, 8, 9),
    (5, 11, 7, 6)
]

_D20Vertices = [
    [-1.213522, -0.700616, -0.267640],
    [+0.000001, -0.865941, -1.133683],
    [+0.000001, -1.401276, +0.267473],
    [-0.750007, +0.433143, -1.133683],
    [+1.213526, +0.700590, +0.267716],
    [+0.000001, +0.865930, +1.133700],
    [+0.750000, -0.433108, +1.133589],
    [+0.000001, +1.401267, -0.267455],
    [-0.750007, -0.433108, +1.133589],
    [-1.213522, +0.700590, +0.267716],
    [+0.750000, +0.433143, -1.133683],
    [+1.213526, -0.700616, -0.267640],
]

_D20Faces = [
    (10, 1, 3),
    (1, 10, 11),
    (4, 11, 10),
    (6, 11, 4),
    (4, 5, 6),
    (6, 5, 8),
    (8, 5, 9),
    (8, 9, 0),
    (9, 3, 0),
    (3, 1, 0),
    (7, 3, 9),
    (7, 5, 4),
    (7, 9, 5),
    (7, 4, 10),
    (7, 10, 3),
    (0, 1, 2),
    (11, 6, 2),
    (2, 6, 8),
    (2, 8, 0),
    (1, 11, 2),
]

_DieTypeModels = {
    common.DieType.D6: (_D6Vertices, _D6Faces),
    common.DieType.D3: (_D6Vertices, _D6Faces),
    common.DieType.DD: (_D6Vertices, _D6Faces),
    common.DieType.D10: (_D10Vertices, _D10Faces),
    common.DieType.D20: (_D20Vertices, _D20Faces),
}

# This was generated by chat-gpt as an exercise to see how it handled
# generating something a little complex. I'm incredibly impressed
# with the results. It's something that would have probably taken me
# a couple of weeks to get what I was looking for, and being so
# cosmetic, it probably wouldn't have been worth the effort. However,
# with just 6-7 hours of (pretty painful) prompt manipulation and a
# bit of manual intervention here and there, I've got code that does
# exactly what I need (although some of the 3d to 2d projection code
# it generated is a little hacky).
class DieAnimationWidget(QtWidgets.QWidget):
    animationComplete = QtCore.pyqtSignal()

    class _SpinState(Enum):
        Idle = 0
        Spinning = 1
        FadingIn = 2

    _UpdateIntervalMs = 30
    _MinSpins = 4
    _MaxSpins = 10
    _90DegreesInRadians = math.radians(90)
    _360DegreesInRadians = math.radians(360)

    def __init__(self, parent: typing.Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self._dieType = None
        self._result = None
        self._strike = False
        self._angleX = 0
        self._angleY = 0
        self._totalRotationX = 0
        self._totalRotationY = 0
        self._spinDirectionX = 0
        self._spinDirectionY = 0
        self._spinStartTime = None
        self._spinDurationMs = 5000
        self._fadeDurationMs = 1000
        self._fadeInProgress = 0
        self._dieColour = QtGui.QColor('#003366')
        self._textColour = QtGui.QColor('#FFCC00')
        self._strikeColour = QtGui.QColor('#FF0000')
        self._spinState = DieAnimationWidget._SpinState.Idle

        self._lightDirection = (0, 0, -1)  # Light coming from the front
        self._ambientLight = 0

        self._timer = QtCore.QTimer(self)
        self._timer.timeout.connect(self._updateAnimation)

        # Mouse control variables
        self._lastMousePosition = None

        self.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.MinimumExpanding,
            QtWidgets.QSizePolicy.Policy.MinimumExpanding)

    def dieType(self) -> typing.Optional[common.DieType]:
        return self._dieType

    def setDieType(self, dieType: typing.Optional[common.DieType]):
        self._dieType = dieType
        self.update() # Trigger redraw

    def dieColour(self) -> QtGui.QColor:
        return self._dieColour

    def setDieColour(self, colour: QtGui.QColor) -> None:
        self._dieColour = colour

    def textColour(self) -> QtGui.QColor:
        return self._textColour

    def setTextColour(self, colour: QtGui.QColor) -> None:
        self._textColour = colour

    def strikeColour(self) -> QtGui.QColor:
        return self._strikeColour

    def setStrikeColour(self, colour: QtGui.QColor) -> None:
        self._strikeColour = colour

    def setLightDirection(self) -> typing.Tuple[float, float, float]:
        return self._lightDirection

    def setLightDirection(self, vector: typing.Tuple[float, float, float]) -> None:
        self._lightDirection = vector

    def ambientLight(self) -> float:
        return self._ambientLight

    def setAmbientLight(self, intensity) -> None:
        self._ambientLight = intensity

    def getSpinDuration(self) -> float:
        return self._spinDurationMs

    def setSpinDuration(self, durationMs: float) -> None:
        self._spinDurationMs = durationMs

    def getFadeDuration(self) -> float:
        return self._fadeDurationMs

    def setFadeDuration(self, durationMs: float) -> None:
        self._fadeDurationMs = durationMs

    def setValue(self, result: int, strike: bool = False) -> None:
        if self._spinState != DieAnimationWidget._SpinState.Idle:
            self.cancelSpin()

        self._result = result
        self._strike = strike
        self._fadeInProgress = 1.0
        self.update()  # Trigger repaint

    def startSpin(self, result: int, strike: bool = False) -> None:
        if self._spinState != DieAnimationWidget._SpinState.Idle:
            self.cancelSpin()

        """ Start spinning the cube with a specified number of rotations and directions. """
        self._spinState = DieAnimationWidget._SpinState.Spinning
        self._fadeInProgress = 0
        self._spinStartTime = time.time()  # Record the start time of the spin

        # Generate a random number of full rotations (1 to 4 rotations for example) and spin direction (-1 or 1)
        self._totalRotationX = random.randint(
            DieAnimationWidget._MinSpins,
            DieAnimationWidget._MaxSpins) * DieAnimationWidget._360DegreesInRadians  # Full rotations for the X-axis
        self._totalRotationY = random.randint(
            DieAnimationWidget._MinSpins,
            DieAnimationWidget._MaxSpins) * DieAnimationWidget._360DegreesInRadians  # Full rotations for the Y-axis
        self._spinDirectionX = random.choice([-1, 1])  # Direction of spin (-1 for counterclockwise, 1 for clockwise)
        self._spinDirectionY = random.choice([-1, 1])  # Direction of spin

        self._result = result  # Store the number to display after the spin
        self._strike = strike

        self._timer.start(30)  # Update every 30 milliseconds

    def skipSpin(self) -> None:
        if self._spinState != DieAnimationWidget._SpinState.Spinning:
            return # Nothing to do

        self._spinState = DieAnimationWidget._SpinState.FadingIn
        self._angleX = 0
        self._angleY = 0
        self.update()  # Trigger repaint

    def cancelSpin(self) -> None:
        self._angleX = 0
        self._angleY = 0
        self._spinState = DieAnimationWidget._SpinState.Idle
        self._result = None
        self._strike = False
        self._timer.stop()

    def minimumSizeHint(self) -> QtCore.QSize:
        return QtCore.QSize(30, 30)

    def sizeHint(self) -> QtCore.QSize:
        return QtCore.QSize(100, 100)

    def paintEvent(self, event) -> None:
        if not self._dieType:
            return

        painter = QtGui.QPainter(self)
        try:
            painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)

            # Cube rendering settings
            width = self.width()
            height = self.height()

            fov = self._calculateFov(width, height)

            vertices, faces = _DieTypeModels[self._dieType]

            # Rotate and project each vertex
            projectedVertices: typing.List[typing.Tuple[
                typing.Tuple[float, float, float],
                typing.Tuple[int, int]]] = []
            for vertex in vertices:
                rotatedVertex = self._rotatePoint(*vertex)
                projected2d = self._project3dTo2d(*rotatedVertex, width, height, fov)
                projectedVertices.append((rotatedVertex, projected2d))

            # Draw each face if visible
            frontFaceRect = None
            for face in faces:
                p1_3d, _ = projectedVertices[face[0]]
                p2_3d, _ = projectedVertices[face[1]]
                p3_3d, _ = projectedVertices[face[2]]

                # Calculate the normal of the face using the transformed 3D vertices.
                # For the D6 the face is split into a right angled triangle covering
                # half the face. This works on the assumption that the entire face is
                # on the same plane
                normal = self._faceNormal(p1_3d, p2_3d, p3_3d)

                # Check if the face is visible
                if self._isFaceVisible(normal):
                    # Calculate the light intensity for flat shading
                    intensity = self._calculateLightIntensity(normal)

                    # Apply the intensity to the base color
                    shadedColor = QtGui.QColor(
                        min(255, int(self._dieColour.red() * intensity)),
                        min(255, int(self._dieColour.green() * intensity)),
                        min(255, int(self._dieColour.blue() * intensity))
                    )

                    # Draw the face as a polygon
                    painter.setBrush(QtGui.QBrush(shadedColor))
                    # TODO: Edge could should be configurable
                    painter.setPen(QtGui.QColor(shadedColor).lighter(280))
                    polygon = QtGui.QPolygon()
                    for index in face:
                        _, p_2d = projectedVertices[index]
                        polygon.append(QtCore.QPoint(*p_2d))
                    painter.drawPolygon(polygon)

                    # Capture the front face bounding box for number display later
                    if face == faces[0]:  # Front face
                        minX = maxX = minY = maxY = None
                        for index in face:
                            _, p_2d = projectedVertices[index]
                            if maxX == None or p_2d[0] > maxX:
                                maxX = p_2d[0]
                            if minX == None or p_2d[0] < minX:
                                minX = p_2d[0]
                            if maxY == None or p_2d[1] > maxY:
                                maxY = p_2d[1]
                            if minY == None or p_2d[1] < minY:
                                minY = p_2d[1]
                        frontFaceRect = QtCore.QRect(minX, minY, maxX - minX, maxY - minY)

            # After spinning, draw the number on the front face
            if self._spinState != DieAnimationWidget._SpinState.Spinning and self._result is not None:
                assert(frontFaceRect)
                displayText = str(self._result)

                displayRect = QtCore.QRect(frontFaceRect)
                if self._dieType == common.DieType.D10 or \
                    self._dieType == common.DieType.D20:
                    # HACK: Don't try to draw the text inside the front face of a
                    # D10 & D20 in the same way as is done for the D6 as the text
                    # would need to be to small to fit inside the triangular
                    # face. The side of the text will still be based on the size
                    # of the face (so a bit smaller than the text for the D6) but
                    # it's moved up based on the height of the face as it gives
                    # a more 'centred look' (the exact amount is arbitrary).
                    vertMove = int(displayRect.height() * -0.1)
                    displayRect.adjust(0, vertMove, 0, vertMove)


                # Calculate font size based on the size of the front face
                margin = 0.1  # 10% margin on each side
                availableWidth = int(displayRect.width() * (1 - 2 * margin))
                availableHeight = int(displayRect.height() * (1 - 2 * margin))
                font = gui.sizeFontToFit(
                    orig=self.font(),
                    text=displayText,
                    rect=QtCore.QRect(0, 0, availableWidth, availableHeight))
                if font:
                    # Set font and color
                    painter.setPen(QtGui.QPen(self._textColour, 1))
                    painter.setFont(font)

                    # Calculate the position to center the text in the front face
                    textRect = painter.fontMetrics().boundingRect(displayText)
                    ascent = painter.fontMetrics().ascent()
                    descent = painter.fontMetrics().descent()

                    # Calculate the text opacity based on fade progress
                    painter.setOpacity(self._fadeInProgress)

                    # Draw the number in the center of the front face
                    painter.drawText(
                        displayRect.center().x() - textRect.width() // 2,
                        displayRect.center().y() + (ascent - descent) // 2,
                        displayText)

                    if self._strike:
                        painter.setOpacity(self._fadeInProgress * 0.8)
                        strikeExpand = int(displayRect.width() * 0.1)
                        stringWidth = int(displayRect.width() * 0.15)
                        strikeRect = QtCore.QRect(frontFaceRect)
                        strikeRect.adjust(
                            -strikeExpand,
                            -strikeExpand,
                            strikeExpand,
                            strikeExpand)
                        painter.setPen(QtGui.QPen(
                            self._strikeColour,
                            stringWidth,
                            QtCore.Qt.PenStyle.SolidLine,
                            QtCore.Qt.PenCapStyle.RoundCap))
                        painter.drawLine(
                            strikeRect.topRight(),
                            strikeRect.bottomLeft())

                    painter.setOpacity(1.0)  # Reset the painter's opacity
        except Exception as ex:
            # TODO: Log something at Debug level to avoid spam if something
            # goes wrong. If I ever need someone to debug this I can ask
            # them to turn up the debug level
            pass
        finally:
            painter.end()

    """
    def mousePressEvent(self, event: QtGui.QMouseEvent) -> None:
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self._lastMousePosition = event.pos()

    def mouseMoveEvent(self, event: QtGui.QMouseEvent) -> None:
        if self._lastMousePosition is not None:
            dx = event.x() - self._lastMousePosition.x()
            dy = event.y() - self._lastMousePosition.y()

            self._angleY += dx * 0.5  # Adjust sensitivity as needed
            self._angleX -= dy * 0.5  # Adjust sensitivity as needed

        self._lastMousePosition = event.pos()

    def mouseReleaseEvent(self, event: QtGui.QMouseEvent) -> None:
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            self._lastMousePosition = None  # Reset on mouse release
    """

    def _easingFunction(self, progress: float) -> float:
        """ A cubic easing function to smoothly slow down the rotation. """
        return 1 - (1 - progress) ** 3  # Smooth out the transition

    def _updateAnimation(self) -> None:
        wasAnimating = self._spinState != DieAnimationWidget._SpinState.Idle

        try:
            if self._spinState == DieAnimationWidget._SpinState.Spinning:
                elapsedTimeMs = (time.time() - self._spinStartTime) * 1000

                # Progress of the animation (0.0 to 1.0)
                animationProgress = min(1.0, elapsedTimeMs / self._spinDurationMs)

                # Easing the progress
                easedProgress = self._easingFunction(animationProgress)

                # Calculate the current angle based on the total rotations, spin direction, and progress
                self._angleX = self._spinDirectionX * easedProgress * self._totalRotationX
                self._angleY = self._spinDirectionY * easedProgress * self._totalRotationY

                # Stop spinning when the progress is done
                if animationProgress >= 1.0:
                    self._angleX = self._snapToNearestFace(self._angleX)
                    self._angleY = self._snapToNearestFace(self._angleY)
                    self._spinState = DieAnimationWidget._SpinState.FadingIn

            if self._spinState == DieAnimationWidget._SpinState.FadingIn:
                increment = 1 / (self._fadeDurationMs / DieAnimationWidget._UpdateIntervalMs)
                self._fadeInProgress += increment
                if self._fadeInProgress >= 1.0:
                    self._fadeInProgress = 1.0
                    self._spinState = DieAnimationWidget._SpinState.Idle
        except Exception as ex:
            logging.error('Failed to update die animation', exc_info=ex)
            self._angleX = self._angleY = 0
            self._spinState = DieAnimationWidget._SpinState.Idle

        self.update()  # Trigger repaint

        isAnimated = self._spinState != DieAnimationWidget._SpinState.Idle
        if wasAnimating and not isAnimated:
            self._timer.stop()
            self.animationComplete.emit()

    def _snapToNearestFace(self, angle: float) -> float:
        """ Snap the angle to the nearest face (multiples of 90 degrees). """
        return round(angle / DieAnimationWidget._90DegreesInRadians) * \
            DieAnimationWidget._90DegreesInRadians

    def _rotatePoint(
            self,
            x: float,
            y: float,
            z: float,
            ) -> typing.Tuple[float, float, float]:
        """ Apply 3D rotation around X, Y, and Z axes. """
        # Rotate around X-axis
        cosX, sinX = math.cos(self._angleX), math.sin(self._angleX)
        y, z = y * cosX - z * sinX, y * sinX + z * cosX

        # Rotate around Y-axis
        cosY, sinY = math.cos(self._angleY), math.sin(self._angleY)
        x, z = x * cosY + z * sinY, -x * sinY + z * cosY

        return x, y, z

    def _calculateFov(
            self,
            width: int,
            height: int
            ) -> float:
        """ Calculate the required FOV to make spinning cube fill the available space without extending outside it """
        distance = max(0.1, 4 + -1)
        minDimension = width if width < height else height
        minDimension *= 0.7
        return (minDimension / 2) * distance / 1

    def _project3dTo2d(
            self,
            x: float,
            y: float,
            z: float,
            width: int,
            height: int,
            fov: float
            ) -> typing.Tuple[int, int]:
            # Convert FoV from degrees to radians
            fov = math.radians(55)

            # Compute the focal length from the FoV
            focalLength = width / (2 * math.tan(fov / 2))

            # Avoid division by zero for points at z = 0
            z += 4
            if z == 0:
                z = 1e-5

            # Perspective projection formula using focal length derived from FoV
            x_2d = ((focalLength * x) / z) + (width / 2)
            y_2d = ((focalLength * -y) / z) + (height / 2)

            return int(x_2d), int(y_2d)

    def _faceNormal(
            self,
            v1: typing.Tuple[float, float, float],
            v2: typing.Tuple[float, float, float],
            v3: typing.Tuple[float, float, float]
            ) -> typing.Tuple[float, float, float]:
        """ Calculate the normal of a face using the cross product of two vectors. """
        ax, ay, az = v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]
        bx, by, bz = v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]

        nx = ay * bz - az * by
        ny = az * bx - ax * bz
        nz = ax * by - ay * bx

        # Calculate the magnitude of the normal vector
        magnitude = math.sqrt(nx**2 + ny**2 + nz**2)

        # Normalize the normal vector if the magnitude is not zero
        if magnitude > 0:
            nx /= magnitude
            ny /= magnitude
            nz /= magnitude

        return nx, ny, nz

    def _calculateLightIntensity(self, normal: typing.Tuple[float, float, float]) -> float:
        """ Calculate light intensity based on the normal direction. """
        intensity = max(0, self._dotProduct(normal, self._lightDirection))  # Clamp to 0 for no negative light
        intensity = min(1.0, intensity + self._ambientLight)

        # Return intensity as a value between 0 and 1
        return intensity

    def _isFaceVisible(self, normal: typing.Tuple[float, float, float]) -> bool:
        """ Determine if a face is visible based on its normal direction. """
        # NOTE: When chat-gpt generated the code it sets this to 0. However,
        # that results in draw artifacts because some edges that shouldn't be
        # visible are draw. I think it has something to do with the fact the
        # normal check isn't taking perspective projection into acount but
        # I can't figure out what it should do (chat-gpt has been no help) and
        # it doesn't seem worth the time trying to figure it out when this
        # hack seems to work.
        # The value of -0.26 was derived from looking at what the values
        # were in the debugger at the point edges should have disappeared but
        # haven't. It was originally -0.25 which was fine for a D6 but when
        # I added D10 & D20 support I found I needed to tweak it to -0.24 so
        # that heavily sloped faces weren't being incorrectly culled.
        # NOTE: When using orthogonal projection this value should be set to 0.0
        return normal[2] < -0.24  # Simple visibility check: face normal pointing towards the camera

    def _dotProduct(self, v1: typing.Tuple[float, float, float], v2: typing.Tuple[float, float, float]) -> float:
        """ Calculate the dot product of two vectors. """
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]
