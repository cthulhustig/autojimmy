import enum
import io
import json
import logging
import math
import os
import PIL.Image
import PIL.ImageDraw
import travellermap
import typing

# Returns true if rect1 is completely contained within rect2
# Rect format is (left, top, right, bottom)
# NOTE: This assumes that rects are valid (i.e. rect1.left <= rect1.right)
def _isContained(
        rect1: typing.Tuple[float, float, float, float],
        rect2: typing.Tuple[float, float, float, float]
        ) -> bool:
    return (rect1[0] >= rect2[0]) and (rect1[1] >= rect2[1]) and \
        (rect1[2] <= rect2[2]) and (rect1[3] <= rect2[3])

# Rect format is (left, top, right, bottom)
# NOTE: This assumes that rects are valid (i.e. rect1.left <= rect1.right)
def _calculateIntersection(
        rect1: typing.Tuple[float, float, float, float],
        rect2: typing.Tuple[float, float, float, float]
        ) -> typing.Optional[typing.Tuple[float, float, float, float]]:
    left = max(rect1[0], rect2[0])
    right = min(rect1[2], rect2[2])
    if left >= right:
        return None

    top = max(rect1[1], rect2[1])
    bottom = min(rect1[3], rect2[3])
    if top >= bottom:
        return None

    return (left, top, right, bottom)

class _MapTile(object):
    def __init__(
            self,
            image: travellermap.MapImage,
            scale: int
            ) -> None:
        self._scale = scale
        with PIL.Image.open(io.BytesIO(image.bytes())) as pixelData:
            self._pixels = pixelData.tobytes()
            self._size = (pixelData.width, pixelData.height)
            self._mode = pixelData.mode

    def scale(self) -> int:
        return self._scale

    def pixels(self) -> bytes:
        return self._pixels

    def size(self) -> typing.Tuple[int, int]:
        return self._size

    def mode(self) -> str:
        return self._mode

    def __lt__(self, other: '_MapTile') -> bool:
        if self.__class__ is other.__class__:
            return self.scale() > other.scale()
        return NotImplemented

class _CustomSector(object):
    def __init__(
            self,
            name: str,
            position: typing.Tuple[int, int],
            mapImages: typing.Iterable[_MapTile]
            ) -> None:
        self._name = name
        self._position = position
        self._mapImages = sorted(mapImages)

        absoluteRect = travellermap.sectorBoundingRect(position[0], position[1])
        mapSpaceUL = travellermap.absoluteHexToMapSpace(
            absoluteRect[0],
            absoluteRect[1] + absoluteRect[3])
        mapSpaceBR = travellermap.absoluteHexToMapSpace(
            absoluteRect[0] + absoluteRect[2],
            absoluteRect[1])
        self._boundingRect = (
            mapSpaceUL[0], # Left
            mapSpaceUL[1], # Top
            mapSpaceBR[0], # Right
            mapSpaceBR[1]) # Bottom
        
        absoluteRect = travellermap.sectorInteriorRect(position[0], position[1])
        mapSpaceUL = travellermap.absoluteHexToMapSpace(
            absoluteRect[0],
            absoluteRect[1] + absoluteRect[3])
        mapSpaceBR = travellermap.absoluteHexToMapSpace(
            absoluteRect[0] + absoluteRect[2],
            absoluteRect[1])
        self._interiorRect = (
            mapSpaceUL[0], # Left
            mapSpaceUL[1], # Top
            mapSpaceBR[0], # Right
            mapSpaceBR[1]) # Bottom

    # Returned rect is in map space and ordered (left, top, right, bottom)
    def boundingRect(self) -> typing.Tuple[float, float, float, float]:
        return self._boundingRect
    
    # Returned rect is in map space and ordered (left, top, right, bottom)
    def interiorRect(self) -> typing.Tuple[float, float, float, float]:
        return self._interiorRect    

    def findMapImage(
            self,
            scale: typing.Union[int, float]
            ) -> typing.Optional[_MapTile]:
        bestLevel = None
        for level in self._mapImages:
            if bestLevel and scale > level.scale():
                # We've got a possible best level and the one currently being looked at is for a
                # lower scale so use the current best. This works on the assumption that list is
                # ordered highest scale to lowest scale
                break
            bestLevel = level

        return bestLevel

class Compositor(object):
    class Operation(enum.Enum):
        # The tile doesn't overlap any custom sectors so the required tile is just the source tile
        # that is generated by Traveller Map and no composition is required
        NoComposite = 0

        # The tile partially overlaps at least one custom sector so composition is required.
        FullComposite = 1

        # The tile is completely contained within a single custom sector so the required tile  can
        # be generated simply by copying from the (i.e. the Traveller Map tile isn't required)
        SimpleCopy = 2

    # This seems to be the point where things stop being that visible and Traveller Map starts showing
    # the galaxy overlay. If the requested tile has a scale lower than this then there isn't any point
    # in compositing.
    _MinCompositionScale = 1.4

    def __init__(
            self,
            customMapsDir: str
            ) -> Operation:
        self._customMapsDir = customMapsDir
        self._milieuSectorMap: typing.Dict[travellermap.Milieu, typing.List[_CustomSector]] = {}

        self._loadCustomUniverse()

    def compositeOperation(
            self,
            tileX: float,
            tileY: float,
            tileScale: float,
            milieu: travellermap.Milieu
            ) -> Operation:
        if tileScale < Compositor._MinCompositionScale:
            return Compositor.Operation.NoComposite

        # Calculate tile rect in map space
        tileMapUL = travellermap.tileSpaceToMapSpace(
            tileX=tileX,
            tileY=tileY + 1,
            scale=tileScale)
        tileMapBR = travellermap.tileSpaceToMapSpace(
            tileX=tileX + 1,
            tileY=tileY,
            scale=tileScale)
        tileMapRect = (
            tileMapUL[0], # Left
            tileMapUL[1], # Top
            tileMapBR[0], # Right
            tileMapBR[1]) # Bottom
        
        sectorList = self._milieuSectorMap.get(milieu)

        for sector in sectorList:
            sectorMapRect = sector.interiorRect()
            if _isContained(tileMapRect, sectorMapRect):
                return Compositor.Operation.SimpleCopy

        for sector in sectorList:
            sectorMapRect = sector.boundingRect()
            intersection = _calculateIntersection(sectorMapRect, tileMapRect)
            if intersection:
                return Compositor.Operation.FullComposite
            
        return Compositor.Operation.NoComposite

    def composite(
            self,
            tileImage: PIL.Image,
            tileX: float,
            tileY: float,
            tileWidth: int,
            tileHeight: int,
            tileScale: float,
            milieu: travellermap.Milieu
            ) -> None:
        if tileScale < Compositor._MinCompositionScale:
            return # Nothing to do (shouldn't happen if correctly checking which operation to use)

        tileMapUL = travellermap.tileSpaceToMapSpace(
            tileX=tileX,
            tileY=tileY + 1,
            scale=tileScale)
        tileMapBR = travellermap.tileSpaceToMapSpace(
            tileX=tileX + 1,
            tileY=tileY,
            scale=tileScale)
        tileMapRect = (
            tileMapUL[0], # Left
            tileMapUL[1], # Top
            tileMapBR[0], # Right
            tileMapBR[1]) # Bottom

        # TODO: There is an annoying graphics issue that can occur if two custom sectors
        # are horizontally next to each other. If the name of one of the edge worlds from
        # the first sector processed overlaps the hex from the adjacent sector. When the
        # adjacent sector is overlayed on the tile will be overwritten. The only solution
        # I can see to that problem is switching so the custom sector mip levels have a
        # completely transparent background. However this introduces a load more problems
        # that are worse, such as issues with the * placeholders and things like trade
        # routes being rendered on the tile by Traveller Map and not overwritten
        # (especially if a custom sector was dropped over an existing populated sector).
        sectorList = self._milieuSectorMap.get(milieu)
        for sector in sectorList:
            sectorMapRect = sector.boundingRect()
            intersection = _calculateIntersection(sectorMapRect, tileMapRect)
            if not intersection:
                continue # No intersection so just use base tile data

            # The custom sector overlaps the tile so copy the section that overlaps to
            # the tile

            mapImage = sector.findMapImage(scale=tileScale)
            if not mapImage:
                continue

            # NOTE: Y-axis is flipped due to map space having a negative Y compared to other
            # coordinate systems
            srcPixelRect = (
                round((intersection[0] - sectorMapRect[0]) * mapImage.scale()), # Left
                -round((intersection[3] - sectorMapRect[3]) * mapImage.scale()), # Upper
                round((intersection[2] - sectorMapRect[0]) * mapImage.scale()), # Right
                -round((intersection[1] - sectorMapRect[3]) * mapImage.scale())) # Lower

            tgtPixelDim = (
                round((intersection[2] - intersection[0]) * tileScale),
                round((intersection[3] - intersection[1]) * tileScale))
            tgtPixelOffset = (
                math.ceil((intersection[0] * tileScale) - (float(tileX) * tileWidth)),
                -math.ceil((intersection[3] * tileScale) + (float(tileY) * tileHeight)))

            # Convert the map image bytes to an image each time. The Image can't be shared between
            # threads as things like crop aren't thread safe
            # https://github.com/python-pillow/Pillow/issues/4848
            srcImage = PIL.Image.frombytes(
                mapImage.mode(),
                mapImage.size(),
                mapImage.pixels())
            try:
                cropImage = srcImage.crop(srcPixelRect)
                del srcImage
                srcImage = cropImage

                # Scale the source image if required
                if (srcImage.width != tgtPixelDim[0]) or (srcImage.height != tgtPixelDim[1]):
                    resizedImage = srcImage.resize(
                        tgtPixelDim,
                        resample=PIL.Image.Resampling.BICUBIC)
                    del srcImage
                    srcImage = resizedImage

                # Copy custom sector section over current tile using it's alpha channel as a mask
                tileImage.paste(srcImage, tgtPixelOffset, srcImage)              
            finally:
                del srcImage

        return tileImage
    
    def copy(
            self,
            tileX: float,
            tileY: float,
            tileScale: float,
            milieu: travellermap.Milieu,
            outputFormat: travellermap.MapFormat
            ) -> bytes:
        if tileScale < Compositor._MinCompositionScale:
            return tileData

        tileMapUL = travellermap.tileSpaceToMapSpace(
            tileX=tileX,
            tileY=tileY + 1,
            scale=tileScale)
        tileMapBR = travellermap.tileSpaceToMapSpace(
            tileX=tileX + 1,
            tileY=tileY,
            scale=tileScale)
        tileMapRect = (
            tileMapUL[0], # Left
            tileMapUL[1], # Top
            tileMapBR[0], # Right
            tileMapBR[1]) # Bottom

        sectorList = self._milieuSectorMap.get(milieu)
        for sector in sectorList:
            if not _isContained(tileMapRect, sector.interiorRect()):
                continue

            sectorMapRect = sector.boundingRect()

            # The tile is completely contained within the custom sector so copy the section of
            # the custom sector that it covers

            mapImage = sector.findMapImage(scale=tileScale)
            if not mapImage:
                continue

            # NOTE: Y-axis is flipped due to map space having a negative Y compared to other
            # coordinate systems
            srcPixelRect = (
                round((tileMapRect[0] - sectorMapRect[0]) * mapImage.scale()), # Left
                -round((tileMapRect[3] - sectorMapRect[3]) * mapImage.scale()), # Upper
                round((tileMapRect[2] - sectorMapRect[0]) * mapImage.scale()), # Right
                -round((tileMapRect[1] - sectorMapRect[3]) * mapImage.scale())) # Lower
            
            tgtPixelDim = (
                round((tileMapRect[2] - tileMapRect[0]) * tileScale),
                round((tileMapRect[3] - tileMapRect[1]) * tileScale))

            # Convert the map image bytes to an image each time. The Image can't be shared between
            # threads as things like crop aren't thread safe
            # https://github.com/python-pillow/Pillow/issues/4848
            srcImage = PIL.Image.frombytes(
                mapImage.mode(),
                mapImage.size(),
                mapImage.pixels())
            try:
                cropImage = srcImage.crop(srcPixelRect)
                del srcImage
                srcImage = cropImage

                # Scale the source image if required
                if (srcImage.width != tgtPixelDim[0]) or (srcImage.height != tgtPixelDim[1]):
                    resizedImage = srcImage.resize(
                        tgtPixelDim,
                        resample=PIL.Image.Resampling.BICUBIC)
                    del srcImage
                    srcImage = resizedImage

                tileData = io.BytesIO()
                srcImage.save(tileData, format=outputFormat.value)
                tileData.seek(0)
                return tileData.read()
            finally:
                del srcImage

        return None

    def _loadCustomUniverse(self) -> None:
        self._milieuSectorMap.clear()

        for milieu in travellermap.Milieu:
            sectors = []
            for sectorInfo in travellermap.DataStore.instance().sectors(milieu=milieu):
                if not sectorInfo.isCustomSector():
                    continue # Only interested in custom sectors

                mapLevels = sectorInfo.mapLevels()
                if not mapLevels:
                    logging.warning(f'Compositor skipping custom sector {sectorInfo.canonicalName()} as it has no map levels')
                    continue

                mapImages = []
                for scale in mapLevels.keys():
                    try:
                        mapImage = travellermap.DataStore.instance().sectorMapImage(
                            sectorName=sectorInfo.canonicalName(),
                            milieu=milieu,
                            scale=scale)
                        mapImages.append(_MapTile(image=mapImage, scale=scale))
                    except Exception as ex:
                        logging.warning(f'Compositor failed to load scale {scale} map image for {sectorInfo.canonicalName()}', exc_info=ex)
                        continue

                sectors.append(_CustomSector(
                    name=sectorInfo.canonicalName(),
                    position=(sectorInfo.x(), sectorInfo.y()),
                    mapImages=mapImages))

            self._milieuSectorMap[milieu] = sectors
